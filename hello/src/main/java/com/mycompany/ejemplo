@RestController
//@RequestMapping("/api/movietype")
public class TypeController {

    TypeService typeService;

    @Autowired
    public TypeController(TypeService typeService) {
        this.typeService = typeService;
    }

    @GetMapping("/{typeMovie}/{daysRented}")
    public ResponseEntity<ResponseType> calculatePriceAndPoints(@PathVariable String typeMovie, @PathVariable int daysRented){
        MovieData data = new MovieData(TypeMovie.valueOf(typeMovie), daysRented);
        return ResponseEntity.status(HttpStatus.OK).body(typeService.calculate(data));
    }
}
@Data
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ResponseType {
    private double price;
    private int frequentRenterPoints;
}
public enum TypeMovie {

    CHILDREN,
    NEW_RELEASE,
    REGULAR

}
@Service
public class TypeService {

    public static final int ZERO = 0;

    public ResponseType calculate(MovieData movieData){
        int frequentRenterPoints = ZERO;
        double price = getAmount(movieData);
        if (movieData.getTypeMovie() == TypeMovie.NEW_RELEASE) {
            frequentRenterPoints = new NewReleaseMovie().getFrequentRenterPoints(movieData.getDaysRented());
        }else{
            frequentRenterPoints++;
        }
        return new ResponseType(price, frequentRenterPoints);
    }

    private double getAmount(MovieData movieData) {
        return switch (movieData.getTypeMovie()){
            case REGULAR -> new RegularMovie().getAmount(movieData.getDaysRented());
            case CHILDREN -> new ChildrenMovie().getAmount(movieData.getDaysRented());
            case NEW_RELEASE -> new NewReleaseMovie().getAmount(movieData.getDaysRented());
            default -> throw new IllegalArgumentException();
        };
    }
}
spring.application.name=servicio-movie-types
server.port=8001

conectarlo y que este coja los resultados de ese controller


@RestController
public class ClienteController {

    @Autowired
    MovieFeignService movieFeignService;

    @Autowired
    public ClienteController(MovieFeignService movieFeignService) {
        this.movieFeignService = movieFeignService;
    }

    @GetMapping("/{typeMovie}/{daysRented}")
    public ResponseEntity<ResponseType> calculatePriceAndPoints(@PathVariable String typeMovie, @PathVariable int daysRented) {
        return movieFeignService.calculatePriceAndPoints(typeMovie, daysRented);
    }
}
@Service
public class MovieFeignService {

    @Autowired
    TypeMovieClientRest typeMovieClientRest;

    public ResponseEntity<ResponseType> calculatePriceAndPoints(String typeMovie,int daysRented){
        return typeMovieClientRest.calculatePriceAndPoints(TypeMovie.valueOf(typeMovie), daysRented);
    }
}
package app.academy.service;

import app.academy.model.ResponseType;
import app.academy.model.TypeMovie;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name= "servicio-movie-types",url = "http://localhost:8001")
public interface TypeMovieClientRest {

    @GetMapping("/api/movietype/{typeMovie}/{daysRented}")
    ResponseEntity<ResponseType> calculatePriceAndPoints(@PathVariable TypeMovie typeMovie, @PathVariable int daysRented);
}
spring.application.name=servicio-rental-service
server.port=8002
spring.datasource.url=jdbc:mysql://localhost:3306/rental_movies
spring.datasource.username=root
spring.datasource.password=rootroot
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.hibernate.ddl-auto=create
spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect
spring.jpa.show-sql=true




package myproject.model.request;

import lombok.Getter;
import lombok.Setter;

import javax.validation.constraints.NotNull;

@Getter
@Setter
public class ClientRequest {

    @NotNull(message = "The name must be not null")
    private String name;
    private String lastName;
    private String email;
    private int age;
}

package myproject.model.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import javax.validation.constraints.NotNull;

@Getter
@Setter
@Entity
@Table(name ="clients")
public class Client {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @NotNull(message = "The name must be not null")
    private String name;
    @Column(name = "last_name")
    private String lastName;
    private String email;
    private int age;
}

import javax.validation.Valid;
import java.net.URI;

@RestController
@RequestMapping("/api/clients")
@Validated
public class ClientController {

    ClientService clientService;
    ClientMapper clientMapper;

    @Autowired
    public ClientController(ClientService clientService, ClientMapper clientMapper) {
        this.clientService = clientService;
        this.clientMapper = clientMapper;
    }

    @PostMapping
    public ResponseEntity<ClientDto> save(@Valid @RequestBody ClientRequest clientRequest){
        Client client = clientService.save(clientMapper.toEntity(clientRequest));
        return  ResponseEntity.created(generateUri(client.getId())).body(clientMapper.toDto(client));
    }

    private URI generateUri(Long clientId)
    {
        return ServletUriComponentsBuilder
                .fromCurrentRequest().path("/{id}")
                .buildAndExpand(clientId)
                .toUri();
    }
}

import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.Objects;

@RestControllerAdvice
public class ControllerAdvice {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<String> handlerClientInvalid(MethodArgumentNotValidException ex){
        return new ResponseEntity<>(Objects.requireNonNull(ex.getFieldError()).getDefaultMessage(), HttpStatus.BAD_REQUEST);
    }
}

