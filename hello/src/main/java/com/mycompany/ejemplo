Develop a program that checks whether the parentheses, curly braces, and square brackets in an expression are balanced.
Balanced means that these delimiters are opened and closed in the correct order and manner.
Parentheses, curly braces, and square brackets have equal priority; there is no one more important than the other.
Balanced expression: { [ a * ( c + d ) ] - 5 }
Unbalanced expression: { a * ( c + d ) ] - 5 }


private PackageAllocation alloc(List<DeliveryTruck> trucks, DeliveryPackage aPackage) {
            PackageAllocation packageAllocation = null;
            for (DeliveryTruck deliveryTruck : deliveryTrucks) {
                if (
                    (deliveryTruck.getDistricts().contains(aPackage.district()) && // It's in same district
                            (deliveryTruck.getCurrentVolume() + aPackage.volume() <= deliveryTruck.getMaxVolume()) && // Has volume cap
                            (deliveryTruck.getCurrentWeight() + aPackage.weight() <= deliveryTruck.getMaxWeight()) // Has weight cap
                )) {
                    packageAllocation = new PackageAllocation(aPackage, deliveryTruck, Status.ALLOCATED);
                    // Update Truck Load
                    deliveryTruck.weigth(deliveryTruck.getCurrentWeight() - aPackage.weight());
                    deliveryTruck.volume(deliveryTruck.getCurrentVolume() - aPackage.volume());
                    
                    break;
                }
            }
            if (packageAllocation == null) {
                throw new RuntimeException("Unable to allocate package id: %s. No truck available".formatted(deliveryPackage.id()));
            }
	     return packageAllocation;
}


import java.util.List;

public class PackageAllocation {
    private DeliveryPackage deliveryPackage;
    private DeliveryTruck deliveryTruck;
    private Status status;

    public PackageAllocation(DeliveryPackage deliveryPackage, DeliveryTruck deliveryTruck, Status status) {
        this.deliveryPackage = deliveryPackage;
        this.deliveryTruck = deliveryTruck;
        this.status = status;
    }

    // Getters y Setters
}

public class DeliveryPackage {
    private int id;
    private int volume;
    private int weight;
    private String district;

    // Constructor, Getters y Setters
}

public class DeliveryTruck {
    private List<String> districts;
    private int maxVolume;
    private int maxWeight;
    private int currentVolume;
    private int currentWeight;

    // Constructor, Getters y Setters

    public void updateLoad(int weight, int volume) {
        currentWeight -= weight;
        currentVolume -= volume;
    }
}

public enum Status {
    ALLOCATED,
    // Otros estados si los hubiera
}


Escribir un programa que mantenga el puntaje de un juego de tenis para dos jugadores. El programa debe recibir como entrada los nombres de los jugadores y debe permitir registrar los puntos que cada jugador gana en cada jugada del juego.

Las reglas del juego de tenis son las siguientes:

El juego comienza con un puntaje de 0-0.
Los puntos se registran como 15, 30 y 40.
Si ambos jugadores tienen un puntaje de 40, se llama "deuce".
A partir del "deuce", el jugador que gane la siguiente jugada obtiene la "ventaja".
Si el jugador sin ventaja gana la siguiente jugada, el puntaje vuelve a estar en "deuce".
Si el jugador con ventaja gana la siguiente jugada, gana un juego (game).
El siguiente juego comienza, hasta que un jugador llega a ganar 6 juegos.
Si los dos jugadores llegan a 5 juegos, entonces el partido se juega a 7 juegos.
Restricciones:

El programa debe implementarse utilizando la técnica de TDD.
El programa debe respetar los conocimientos de código limpio.
Siempre recordar que debemos hacer nuestra estructura de clases y objetos para que sea posible usar por otros devs
No es necesario implementar una interfaz gráfica de usuario, se puede utilizar la consola de comandos para mostrar el puntaje y recibir las jugadas de los jugadores.


package org.example.model;

import java.util.Scanner;

public class TenisMatch {

    private static final int JUEGOS_GANAR_PARTIDO = 2;
    private static final String[] TENIS_POINTS = {"0", "15", "30", "40"};
    private static final int PUNTOS_DEUCE = 4;
    private Player player1;
    private Player player2;

    public TenisMatch(Player player1, Player player2) {
        this.player1 = player1;
        this.player2 = player2;
    }

    public void jugar() {
        while(player1.getTotalSet()<2 && player2.getTotalSet()<2){
            jugarJuego();
        }
        System.out.println("El jugador ha ganado el partido");
    }

    private void jugarJuego() {
        while (!player1.haGanadoJuego() && !player2.haGanadoJuego()) {
            jugarPunto();
        }
        if (player1.haGanadoJuego()) {
            player1.aumentarJuegosGanados();
            if (player1.getWinGames()>5) {
                if (player1.getTotalSet()==0) {
                    System.out.println("El jugador ha ganado un set");
                    player1.setTotalSet(1);
                    player1.setWinGames(0);
                    player1.setTotalPoints(0);
                    player2.setTotalPoints(0);

                }else{
                    System.out.println("El jugador ha ganado el último set");
                    player1.setTotalSet(2);
                    player1.setWinGames(0);
                    player1.setTotalPoints(0);
                    player2.setTotalPoints(0);
                }

            }else{
                System.out.println("Juego para "+player1.getNombre()+"-"+player1.getWinGames());
                player1.setTotalPoints(0);
                player2.setTotalPoints(0);
            }

        } else {
            player2.aumentarJuegosGanados();
            System.out.println("Juego para "+player1.getNombre());
        }

    }

    private void jugarPunto() {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Punto para " + player1.getNombre() + " (1) o " + player2.getNombre() + " (2): ");
        int option = scanner.nextInt();

        if (option == 1) {
            player1.aumentarPuntaje();
        } else if (option == 2) {
            player2.aumentarPuntaje();
        }

        if (estaEnDeuce() && !hayVentaja()) {
            while (Math.abs(player1.getTotalPoints() - player2.getTotalPoints()) < 2) {
                jugarPunto();
            }
        }

    }
    private boolean hayVentaja() {
        return Math.abs(player1.getTotalPoints() - player2.getTotalPoints()) == 1;
    }
    private boolean estaEnDeuce() {
        return player1.getTotalPoints() == PUNTOS_DEUCE && player2.getTotalPoints() == PUNTOS_DEUCE;
    }

}ç





private void playPoint() {
        while (!player1.haGanadoJuego() && !player2.haGanadoJuego()) {
            jugarPunto();
        }




        if (player1.haGanadoJuego()) {
            player1.aumentarJuegosGanados();
            if (player1.getWinGames()>5) {
                if (player1.getTotalSet()==0) {
                    System.out.println("El jugador ha ganado un set");
                    player1.setTotalSet(1);
                    player1.setWinGames(0);
                    player1.setTotalPoints(0);
                    player2.setTotalPoints(0);

                }else{
                    System.out.println("El jugador ha ganado el último set");
                    player1.setTotalSet(2);
                    player1.setWinGames(0);
                    player1.setTotalPoints(0);
                    player2.setTotalPoints(0);
                }

            }else{
                System.out.println("Juego para "+player1.getNombre()+"-"+player1.getWinGames());
                player1.setTotalPoints(0);
                player2.setTotalPoints(0);
            }

        } else {
            player2.aumentarJuegosGanados();
            System.out.println("Juego para "+player1.getNombre());
        }

    }
